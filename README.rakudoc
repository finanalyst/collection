=begin pod

=TITLE Raku Collection Module

=DESCRIPTION Software to collect content files written in Rakudoc (aka POD6) and render
them in a chosen format. Extensive use is made of plugins to customise the rendering.
A distinction is made between the Rakudoc files for the main content (sources) and the Rakudoc
files that describe the whole collection of sources (mode-sources), eg. the landing page (I<index.html>) of a website,
or the Contents page of the same sources in book form.
The collection process is in stages
at the start of which plugin callables (Raku programs) can be added that transform intermediate data or add
templates, or add new Pod::Blocks for the rendering.

=AUTHOR Richard Hainsworth aka finanalyst

This module is used by the module B<Collection-Raku-Documentation>,
but is intended to be more general, such as building a personal site.

=head1 Installation

To install the distribution, a refresh utility (see L<Plugin refreshing>),
and the default plugin directory (see L<Released plugin directory>), use

    zef install Collection

For those who really want to have a non-default plugin directory, it is possible.
But B<warning>: extra user input will be needed for
other utilities, so read the whole of this file), eg, to have a hidden directory
C<.Collection> in the home directory (under *nix), use

    PluginPath=~/.Collection zef install Collection

=head1 Usage

The Collection module expects there to be a C<config.raku> file in the root of the collection, which provides information
about how to obtain the content (Pod6/rakudoc> sources, a default Mode to render and output the collection. All the configuration,
template, and plugin files described below are B<Raku> programs that evaluate to a Hash. They are described in the
documentation for the C<RakuConfig> module.

A concrete example of C<Collection> is the L<Collection-Raku-Documentation (CRD)|https://github.com/finanalyst/collection-raku-documentation.git>
module. I<CRD> contains a large number of plugins (see below). Some plugin examples are constructed
for the extended tests. Since the test examples files are deleted by the final test, try:

    NoDelete=1 prove6 -I. xt

and then look at eg., C<xt/test-dir>.

The main subroutine is C<collect>. It requires a file C<config.raku> to be in the C<$CWD> (current working directory).
In I<CRD> the executable C<Raku-Doc> initiates the collection by setting up sources and installing a C<config.raku>
file. It is then simply a command line interface to C<collect>.

=head1 Life cycle of processing

The content files are processed in several stages separated
by milestones. At each milestone, intermediary data can be processed
using plugin callables, the data after the plugin callables can be dumped, or the processed halted.

C<collect> can be called with option flags, which have the same effect as configuration options. The run-time values
of the L<Control flags> take precedence over the configuration options.

C<collect> should be called with a L<Mode>. A B<Mode> is the name of a set of configuration files, templates,
and plugins that control the way the source files are processed and rendered. The main configuration file must
contain a key called C<mode>, which defines the default mode that C<collect> uses if called with no explicit
mode, so if C<collect> is called without a B<Mode>, the default will be used.

=head1 Modes

A Mode:
=item is the name of the process by which a I<Collection> is rendered and presented.
At present, only C<Website> is implemented, but it is planned to have Modes for
C<epub> and C<pdf> formats. The presentation may be serving HTML files locally,
or the creation of a single epub file for publishing.

=item is the name of a sub-directory under the Collection directory.
=item may not be named with any '_' in it. This allows for sub-directories in a
Collection folder that are not modes, eg., a Raku documentation repository

=item A Mode sub-directory must contain:
=item2 a sub-directory C<configs>, and/or a C<config.raku> file.

=head1 Milestones

The C<collect> sub can be called once the collection directory contains a C<config.raku>,
which in turn contains the location of a directory of rakudoc source files,
which must contain recursively at least one source.

Processing occurs during a stage named by the milestone which starts it.
Each stage is affected by a set of L<Control flags>.
Certain flags will be passed to the underlying objects, eg. C<RakuConfig> and C<ProcessedPod> (see
C<Raku::Pod::Render>).

Plugin callables may be called at each milestone (except 'Source' and 'Mode', where they are not defined).
Plugins are described in more detail in L<Plugin management>. plugin callables are milestone specific, with the call
parameters and return values depending on the milestone.

The milestones are:
=item Source
=item Mode
=item Setup
=item Render
=item Compilation
=item Transfer
=item Report
=item Completion

=head2 Stopping or dumping information at milestones

Intermediate data can be dumped at the milestone
B<without stopping> the processing, eg.,

    collect(:dump-at<source render>);

Alternatively, the processing can be B<stopped> and intermediate data inspected,
EITHER after the stage has run,
but before the plugin callables for the next stage have been triggered, eg.,

    my $rv = collect(:after<setup>);

OR after the previous stage has run and after the plugin callables for the milestone have been triggered, eg.,

    my $rv = collect(:before<render>);

The return value C<$rv> is an array of the objects provided to plugin callables at that milestone, and an array of
the plugin callables triggered (note the plugin callables used will be a difference between the C<:before> and C<:after> stop points).
The plugins-used array is not provided to all plugin callables, except at the Report milestone.

The return value C<$rv> at C<:after> will contain the object provided by the milestone after the named milestone.
For example, milestone milestone 'Setup' is followed by milestone 'Render'.
The return object for C<:after<setup>> will be the
return object for milestone 'Render'. See Milestones for more information.

The object returned by C<:before<render>> may be affected by the plugin callables that are triggered before the named stage.

The C<:before>, C<:after> and C<:dump-at> option values are the (case-insensitive) name(s) of the inspection point for the milestone.
C<:before> and C<:after> only take one name, but C<:dump-at> may take one or all of them in a space-delimited unordered list.

The C<dump-at> option calls C<.raku>
[TODO pretty-dump, when it handles BagHash and classes] on the same objects as above
and then outputs them to a file(s) called C<dump-at-<milestone name>.txt>.

=head2 Source Milestone

(Skipped if the C<:without-processing> flag is True)

Since this is the start of the processing, no plugins are defined as there are no objects for them to operate on.

The C<config.raku> file must exist and must contain a minimum set of keys. It may optionally contain keys for
the control flags that control the stage, see below. The intent is to keep the options for the root configuration file
as small as possible and only refer to the source files. Most other options are configured by the Mode.

During the subsequent B<Source> stage, the source files in the collection are brought in, if the collection has not been
fully initiated, using the C<source-obtain> configaturation list. Alternatively, any updates are brought in
using the C<source-refresh> list. Commonly, sources will be in a I<git> repository, which has separate commands for
C<clone> and C<pull>. If the C<source-obtain> and C<source-refresh> options are not given (for example during a test),
no changes will be made to the source directory.

Any changes to the source files are cached by default.

The control flags for this stage are:
=begin item
B<no-refresh> (default False)

Prevents source file updates from being brought in.

=end item
=begin item
B<recompile>

Forces all the source files to be recompiled into the cache.

=end item

=head2 Mode Milestone

(Skipped if the C<:without-processing> flag is True)

Collection makes a distinction between Rakudoc source files that are the main content, and the source files needed to
integrate the main content into a whole. The integration sources will differ according to the final output. For example,
a book may have a Foreward, a Contents, a Glossary, etc, whilst a website will have a landing page (eg., I<index.html>),
and perhaps other index pages for subsections. A book may also organise content into sections that depend on metadata in
the source files. A book will have a defined order of sections, but a website has no order. A website will require
CSS files and perhaps jQuery scripts to be associated with Blocks. A book will have different formating requirements for
pages.

These differences are contained in the B<mode> configuration, and the plugins and templates for the mode.

At this milestone, the source files have been cached. The B<mode> sub-directory has not been tested, and the configuration
for the mode has not been used. Since plugin management is dependent on the mode configuration, no plugin callables can be called.

The B<return value> of C<collect> with C<:after<source>> is a single
C<Pod::From::Cache> object that does a C<Post-Cache> role (see below for C<Post-Cache> methods).

A C<Pod::From::Cache> object provides a list of updated files, and a full set of source files. It will
provide a list of Pod::Blocks contained in each content files, using the filename as the key.

During the stage the source files for the Mode are obtained, compiled and cached. The process is controlled by the
same options as the I<Source> stage. For example, the B<Mode> for C<Collection-Raku-Documentation> is I<Website>.

If a sub-directory with the same name as I<mode> does not exist, or there are no config files in the C< <mode>/config> directory,
C<collect> will throw an C<X::Collection::NoMode> exception at the start of the stage.

Mode source files are stored under the mode sub-directory and cached there. If the mode source files are stored remotely and
updated independently of the collection, then the C<mode-obtain> and C<mode-refresh> keys are used.

=head2 Setup Milestone

(Skipped if the C<:without-processing> flag is True)

If B<setup> plugin callables are defined and in the mode's plugins-required<setup> list, then the cache objects for
the sources and the mode's sources (and the B<full-render> value)
are passed to the program defined by the plugin's B<setup> key.

The purpose of this milestone
is to allow for content files to be pre-processed, perhaps to creates several sub-files from one big file, or to combine
files in some way, or to gather information for a search algorithm.

During the setup stage,
=item the C<ProcessedPod> object is prepared,
=item templates specified in the C<templates> directory are added
=item the key B<mode-name> is added to the C<ProcessedPod> object's plugin-data area and given the value of the mode.

The Setup stage depends on the following options:
=begin item
B<full-render>

By default, only files that are changed are re-rendered, which includes an assumption that if any source file
is changed, then all the B<mode> sources must be re-rendered as well. (See the Problems section below for a caveat.)

When B<full-render> is True, the output directory is emptied of content, forcing all files to be rendered.

B<full-render> may be combined with B<no-refresh>, for example when templates or plugins are changed and the aim
is to see what effect they have on exactly the same sources. In such a case, the cache will not be changed, but
the cache object will not contain any files generated by B<setup> plugin callables.
=end item

=head2 Render Milestone

(Skipped if the C<:without-processing> flag is True)

At this milestone C<render> plugins are supplied to the
C<ProcessedPod> object. New Pod::Blocks can be defined, and the templates associated with them can be created.

The source files (by default only those that have been changed) are rendered. 

The stage is controlled by the same options as I<Setup> and
=item with-only - affects which Documents are rendered, see Configuration for more
=item ignore - prevents docs from being Cached, see Configuration for more

=head2 Compilation Milestone

(Skipped if the C<:without-processing> flag is True)

During the stage after this milestone, the structure documents are rendered. They can
have Pod-blocks which use data included by templates and plugins during the render stage.
They can also add to data, which means that the order in which a plugin is called
may be important.

At this milestone plugin callables are provided to add compiled data to the C<ProcessedPod> object, so that the sources
in the mode's directory can function.

During the B<Render> stage, the C<%processed> hash is constructed whose keys are the filenames of the output files, and whose
values are a hash of the page components of each page.

The C<compilation> plugin callables could, eg, collect page component data (eg., Table of Contents, Glossaries, Footnotes),
and write them into the C<ProcessedPod> object separately so there is a TOC, Glossary, etc structure whose keys
are filenames.

The return value of C<collect> at the inspection point is a list of C<ProcessedPod>, C<%process>, with the C<ProcessedPod>
already changed by the C<compilation> plugin callables.

The stage is controlled by the same options as I<Setup> and
=item with-only - same as include but for structure documents
=item ignore-mode - as for ignore above

=head2 Transfer Milestone

(Skipped if the C<:without-processing> flag is True)

Plugins may generate assets that are not transfered by them, or it is important to ensure
that a plugin runs after all other plugins.

In addition, render plugins may create files that are transfered at the render stage, but should
be removed after all plugins have run. So a transfer milestone plugin can be created to
clean up the plugin's local directory.

=head2 Report Milestone

(Skipped if the C<:without-processing> flag is True)

Once a collection has been rendered, all the links between files, and to outside targets can be subjected to
tests. It is also possible to subject all the rendered files to tests. This is accomplished using C<report> plugin callables.

In addition, all the plugin callables that have been used at each stage (except for the Report stage itself) are listed.
The aim is to provide information for debugging.

The report stage is intended for testing the outputs and producing reports on the tests.

=head2 Completion Milestone

Once the collection has been tested, it can be activated. For example, a collection could be processed into a book,
or a C<Cro> App run that makes the rendered files available on a browser. This is done using C<completion> plugin callables.

The B<without-completion> option allows for the completion phase to be skipped.

Setting B<without-processing> to True and B<without-completion> to True should have no effect unless
=item there are no caches, which will be the case the first time C<collect> is run
=item the destination directory is missing, which will be the case the first time C<collect> is run

=head1 Collection Structure

A distribution contains content files, which may be updated on a regular basis, a cache,
templates, extra assets referenced in a content file (such as images), and one or more modes.

=head2 Collection Content

The content of the distribution is contained in B<rakudoc> files. In addition to the source files, there are
Collection content files which express things like the Table of Contents for the whole collection.

Collection content are held separately to the source content, so that each mode may have different pages.

This allows for active search pages for a Website, not needed for an epub, or publisher data for an output
formation that will be printed.

=head2 Extra assets (images, videos, etc)

Assets such as images, which are directly referenced in content file, but exist in different formats, eg, png,
are held apart from content Pod6 files, but are processed with content files.

The reasoning for this design is that Pod6 files are compiled and cached in a manner that does not suit
image files. But when an image file is processed for inclusion in a content file, the image may need to be
processed by the template (eg., image effects specified in a Pod Block config).

The assets are all held in the same directory, specified by the configuration key C<asset-basenamme>, but each asset
may exist in subdirectories for each type of asset, specified by the C<asset-paths> key.

(Asset files relating to the rendering of a content file, such as css, javascript, etc, are managed by
plugins, see below for more on plugins.)

A class to manage asset files is added to the C<ProcessedPod> object with a role, so the assets can be manipulated by
plugins and templates. Assets that are in fact used by a Pod content file are marked as used. The aim of
this functionality is to allow for report-stage plugin callables to detect whether all images have been used.

Plugins can also transform the assets, and create new files in the ProcessedPod object for inclusion in
the output.

At the end of the compilation stage, all the assets that have been used are written to a directory
specified in the Mode configuration file. It is the task of the template rendering block to ensure that the
path where the asset is stored is the same as the path the final output (eg. the browser rendering html files)
processor requests.

In keeping with the principle that collection level meta data is kept in the top-level config file, and output data is
associated with the specific mode, there are two asset-path definitions.
=begin item
Collection level assets. The source of assets is kept in the top-level C<config.raku> file. In order to have each asset
in its own directory, the following is possible:

    ...
    :asset-basename<assets>,
    asset-paths => %(
        image => %(
            :directory<images>,
            :extensions<png jpeg jpeg svg>,
        ),
        video-clips => %(
            :directory<videos>,
            :extensions<mp4 webm>,
        ),
    ),
    ...

Notice that the C<type>, eg. I<image> and I<video-clips> above, are arbitrary and not dependent on the actual format.

=end item
=begin item
Output configuration. The output destination is kept in the mode  configuration, eg., C<Website/configs/03-images.raku> contains

    %(
        :asset-out-path<html/assets>
        ),
    )

For more see L<Asset-cache methods>

=end item

=head2 Cache

The B<cache> is a Precomp structure into which the content files are pre-preprocessed.

=head2 Mode

The B<Mode> is the collection of templates and configuration for some output. A collection may contain
multiple Modes, each in their own subdirectory.

The default Mode for B<Collection-Raku-Documentation> is B<Website>, for example.

The string defining C<mode> must refer to an immediate directory of the root of the collection,
so it is compared to C</ ^ \W+ (\w+) '/'? .* $ /> and
only the inner C<\w> chars are used.

The templates, configuration, output files, and other assets used by a Mode are associated with the Mode, and should
reside beneath the Mode sub-directory.

=head2 Templates

The B<templates>, which may be any format (currently RakuClosure or Mustache) accepted by
C<ProcessedPod>, define how the following are expressed in the output:
=item the elements of the content files, eg. paragraphs, headers
=item the files as entities, eg, whether as single files, or chapters of a book
=item the collective components of content files, viz, Table of Contents, footnotes, Glossary, Meta data
=item All the templates may be in one file, or distributed between files.
=item2 If there are no templates in the directory, the default files in C<ProcessedPod> are used.
=item2 If there are multiple files in the directory, they will all be evaluated in alphanumeric order.
Note that existing keys will be over-written if they exist in later templates. This is B<not> the same
behaviour as for Configuration files.

=head1 Configuration

There are three levels of configuration:
=item The top-level configuration resides in C<config.raku> in the root directory of the
Collection. The C<collect> sub will fail without this file.

=item The Mode configuration typically resides in the C<configs> directory, in several
files (the names are not important).

=item Each plugin has its own config, in the C<config.raku> file of its directory.

=head2 Top level configuration

In the descriptions below, simple illustrative names are given to files with configuration, templates, callables.
These files are generally B<Raku> programs, which are compiled and run. They will almost certainly contain errors
during development and the B<Rakudo> compiler will provide information based on the filename. So it is good
practice to name the files that make them easier to locate, such as prefixing them with the plugin name.

C<config.raku> B<must> contain the following keys:
=item the B<cache> directory, relative to the root directory of the collection
=item2 C<Collection-Raku-Documentation> default: 'doc-cache',
=item the B<sources> directory, relative to the root of the collection and must contain at least one content file
=item2 C<Collection-Raku-Documentation> default: 'raku-docs'
=item B<mode> is the default mode for the collection, and must be a sub-directory, which must exist and contain
a C<configs> sub-directory (note the plural ending). See Mode level configuration below.

=item2 C<Collection-Raku-Documentation> default: 'Website'
=item B<without-processing> as described in Milestones
=item2 default: False
=item B<no-refresh> as described in Milestones
=item2 default: False
=item B<recompile> as described in Milestones
=item2 default: False

The following are optional keys, together with the defaults
=item the allowed B<extensions> for content files. These are provided to the C<Pod::From::Cache> object.
=item2 default: < rakudoc pod pod6 p6 pm pm6 >
=item no-status This option controls whether a progress bar is provided in the terminal
=item2 default: False
=item B<source-obtain> is the array of strings sent to the OS by C<run> to obtain sources, eg git clone
and assumes CWD is set to the directory of collection. Without this key, there must already be files
in C<sources>.

=item2 default: ()
=item B<source-refresh> is the array of strings run to refresh the sources, assumes CWD set to the directory of sources.
No key assumes the sources never change.

=item2 default: ()
=item B<ignore> is a list of files in the B<sources> directory that are not cached.
This is a Collection level configuration. The option B<include-only> is Mode level
configuration, see below.

=item2 default: ()
=item B<no-status> as described in Milestones
=item2 default: False
=item B<without-report> as described in Milestones
=item2 default: False
=item B<full-render> as described in Milestones
=item2 default: False
=item B<asset-basename> as described in L<Asset-cache methods>
=item2 C<Collection-Raku-Documentation> default: 'asset_base'

=head2 Mode-level configuration

The mode-level configuration resides in one or more B<files> that are under the B<configs/> sub-directory of the
C<mode> directory. This arrangement is used to allow for configuration to be separated into different named
files for ease of management.

The following rules apply:
=item If the B<configs> directory for a mode does not exist or is empty, B<Raku-Doc> (C<collect> sub) will fail.
=item The Configuration consists of one or more C<Raku> files that each evaluate to a hash.
=item2 Each Config file in the B<Configs> directory will be evaluated in alphabetical order.
=item2 Configuration keys may not be over-written. An C<X::RakuConfig::OverwriteKey> exception will be thrown if
an attempt is made to redefine a key.

All the following keys are mandatory.
Where a key refers to a directory (path), it should normally be relative to the C<mode> sub-directory.
=item B<mode-sources> location of the source files for the Collection pages, eg., TOC.
=item B<mode-cache> location of the cache files
=item the B<templates> subdirectory, which must contain raku files as described in C<ProcessedPod>.
These are all passed at the B<Render> milestone directly to the C<ProcessedPod> object.

=item B<destination> directory where the output files are rendered
=item B<report-path> is the path to which C<report> plugins should output their reports.
=item B<plugin-format> defines the format the plugins relate to. Each Mode is specified to produce
output in a specific format, and the plugins, which include templates, are related to the format.
Published plugins are stored for a particular format.

=item B<plugins-required> points to a hash whose keys are milestone names where plugin callables can be applied
=item2 B<setup> a list of plugin names, see L<Plugin management>, for pre-processing cache contents
=item2 B<render> plugins used to render Pod::Blocks
=item2 B<compilation> plugins prepare the C<ProcessedPod> object for collection pages.
=item2 B<assets> plugins that mark assets created in previous milestones
=item2 B<report> plugins to test and report on the rendering process
=item2 B<completion> plugins that define what happens after rendering
=item2 B<cleanup> plugins if cleanup is needed.
=item B<landing-place> is the name of the file that comes first during the completion stage. For example,
in a Website, the landing file is usually called C<index.html>

=item B<output-ext> is the extension for the output files
=item B<plugin-options> is mandatory, see L<Plugin level configuration> for more information

All optional control flags are False by default. For the Mode configuration they are:
=item no-status
=item full-render
=item without-completion
=item without-report
=item no-preserved-state
=item debug-when
=item verbose-when
=item no-code-escape

=head2 Plugin level configuration

Each plugin has its own configuration (more information in the sections on Plugins).
In addition to the mandatory keys, a plugin may have its own configuration data.
The configuration data in the plugin directory will be over-written each time a plugin
is updated.

In order to provide for preservation of configuration data at the Mode level,
the key C<plugin-options> (typically kept in a separate config file) is used.
The value of C<plugin-options> is a Hash whose keys are the names of plugins. Each
plugin-name key has a value that is a Hash of the keys required by the plugin.

For example, the C<Collection-Raku-Documentation> plugin C<cro-app> has
the configuration options C<:port> and C<:host>. The default C<Collection-Raku-Documentation>
configuration contains the snippet:

        plugin-options => %(
            cro-app => %(
                :port<30000>,
                :host<localhost>,
            ),
        ),

in a file under the Mode's C<configs/> directory. These values will over-ride
the plugin's default config values.

The plugin should therefore take configuration data from the ProcessedPod instance
and not from the config file it is distributed with. This means
that if a new plugin is intended to be used in place of an pre-existing one
(see L<Refresh process>), then the developer needs to check the configuration information
from the namespace of the replaced name.

The Setup and Completion plugins are passed C<plugin-options> directly because the ProcessedPod
instance is out of scope.

C<plugin-options> is a mandatory option in the Mode configuration. It may be set to Empty, viz.,

    plugin-options()

in which case, all plugins will use their default options.

The ProcessPod instance is only modified by C<Render> plugins,
so if there is plugin configuration data that is needed by another Milestone callable, the plugin should call
a blank callable, with empty block and templates.

=head1 Control flags

The control flags are also covered in L<Milestones>. Control flags by default are False.

=begin item
B<no-status>

No progress status is output at any time.
=end item
=begin item
B<without-processing>

Setting B<without-processing> to True will skip all the stages except
B<Completion>, so long as the destination directories exist.

=end item
=begin item
B<no-preserved-state>

In order to allow for changes in some source files, or in only mode files, after all the sources
have been processed once, the processing state must be archived. This may not be needed in testing
or if the archiving takes too long.

Setting no-preserved-state = True prevents storage of state, but also forces B<without-processing> to False,
and B<recompile> to True.
=end item
=begin item
B<recompile>

Controls the updating and caching of the content files. If true, then all files will be recompiled and cached.

A True value is over-ridden by B<without-processing>

Normally False, which allows for only changed files to be processed.

=end item
=begin item
B<no-refresh>

Prevents the updating of content files, so no changes will be made.

=end item
=begin item
B<full-render>

Forces all files to be rendered. Even if there are no changes to source files, plugins or templates
may be added/changed, thus changing the output, so all files need to be re-rendered.

This flag is set to False if B<without-processing> is True.

=end item
=begin item
B<without-report>

Normally, report plugin callables report on the final state of the output files. This flag prevents
report plugin callables from being loaded or run.

If B<without-processing> is set, then the B<Report> stage is skipped. If, however,
the caches do not exist (deleted or first run), then the value of B<without-processing> is ignored and
the value of B<without-report> is observed.

=end item

=begin item
B<debug-when & verbose-when>

ProcessedPod uses C<debug> and C<verbose>, which provide information about which blocks are processed (debug),
and the result after the application of the template (verbose). This is a lot of information and generally, it is only
one file that is of interest.

These two flags take a string, eg., C<:debug-when<Introduction.pod6> >, and when the filename matches
the string, then the debug/verbose flag is set for that file only. (verbose is only effective when
debug is True).

=end item
=begin item
B<collection-info>

Causes collect to produce information about milestones and valid and invalid plugins
=end item
=begin item
B<with-only> filename

Collect is run only with that filename, which must be in the sources or mode-sources, and is specified like C<debug-when>.

The option takes a string containing the filename. An empty string means all filenames in sources and mode-sources.
=end item

=begin item
B<no-code-escape>

C<ProcessedPod> has a special flag for turning off escaping in code sections
when a highlighter is used to pre-process code. In some cases, the highlighter also
does HTML escaping, so RPR has to avoid it.

This has to be done at the Mode level and not left to C<render> plugin callables.
=end item

=head1 Plugin management

Plugin callables are B<Raku> programs that are executed at specific milestones in the rendering process.
The milestone names are given in L<Milestones> above.

The B<plugins-required> key in the Mode's configuration contains a hash with keys whose names are the
milestone names. Each key points to a list of plugin names, which are called in the order
given.

All plugins must reside within the mode B<plugins>.

All plugin names B<must> be the name of a sub-directory under the B<plugins> subdirectory.
Within each plugin sub-directory,
there must be a C<config.raku> file containing information for the plugin, and for C<Collection>.
If I<no> C<config.raku> files exists, the plugin is not valid and will be skipped.

With the exception of 'render' plugin callables, the config file must contain a key for the milestone type,
which points to the program to be called, and when the file is evaluated, it yields a subroutine that
takes the parameters needed for the plugin of that milestone. If no key exists with the name of the milestone,
then the plugin is not valid.

Plugin's may need other configurable data, which should be kept in the config file for the plugin.

All plugin callables are expected to adhere to C<no-status> and C<collection-info>, which are interpretted as
=item C<no-status> if true means 'no output at all', equivalent to a B<quiet> flag
=item C<collection-info> if true means 'output extra information' (if need be), equivalent to a B<verbose> flag.

=head2 Disabling a plugin

When it's necessary to disable a plugin, this can be done by:
=item Removing the plugin name from the C<plugins-required> key of the Mode's config file;
=item Renaming / removing the C<config.raku> file name inside the plugin directory
=item Renaming / removing the milestone key inside the plugin's C<config.raku> file.

=head2 Plugin types

The plugin types are as follows.

=head3 Setup

Config hash must contain B<setup> which is the name of a Raku
program (a callable) that evaluates to a sub that takes a list of five items, eg.,

    sub ( $source-cache, $mode-cache, Bool $full-render, $source-root, $mode-root, %plugin-options, %options ) { ... }

=begin item
B<$source-cache>

A C<Pod::From::Cache+PostCache> object containing the pod of the sources files
New files can be added to the cache object inside the sub using the C<.add> method, see L<Sources>.

=end item
=begin item
B<$mode-cache>

Like the above for the mode content files

=end item
=begin item
B<$full-render>

If True, then the sub should process the cache objects with the .sources method on the cache objects,
otherwise with the .list-files method on the cache objects (the .list-files method only
provides the files that have changed).

=end item
=begin item
B<$source-root>

This path must be prepended to any sources added (see below) to the cache, otherwise they will not be added to the
destination file.

=end item
=begin item
B<$mode-root>

Likewise for the mode sources.

=end item
=begin item
B<%plugin-options>

Has the values of plugin options that over-ride a plugin's own defaults. See L<Plugin level configuration>
for more information.

=end item
=begin item
B<%options>

Has the values of 'collection-info' and 'no-status' flags.

=end item
=head3 Render

The Collection plugin-manager calls the C<ProcessedPod.add-plugin> method with the config keys and
the path modified to the plugin's subdirectory. The ProcessPod instance is only modified by C<Render> plugins,
so if there is plugin configuration data that is needed by another Milestone callable, the plugin should call
a blank callable, with empty block and templates.

If the C<render> key is True, no callable is provided, and the plugin name will be added via the B<.add-plugin>
method of the C<ProcessedPod> object. See C<ProcessedPod> documentation.

If the C<render> key is a Str, then it is the filename of a Raku callable of the form

    sub ( $pr, %options --> Array ) {...}

where

=item B<$pr> is a <ProcessedPod> object,
=item B<%options> is the same as for Setup, and
=item the callable B<returns> a list of triples, with the form (to, from-plug, file)
=item2 B<to> is the destination under the C<%config<destination> > directory where the asset will be
looked for, eg., an image file to be served.

=item2 B<from-plug> is the name of the plugin in whose directory the asset is contained, where the value C<myself>
means the path of the plugin calling the render callable. Actually, 'myself' is the value of Collection::MYSELF.

=item2 B<file> is the filename local to the source plugin's subdirectory that is to be copied to the destination.
This may contain a path relative to the plugin's subdirectory.

=item2 For example for an HTML file, this would be the relative
URL for the C<src> field. Eg., C<to = 'asset/image'>, C<file = 'new-image.png'>, C<from-plug = 'myself'>
and the html would be C< <img src="asset/image/new-image.png" /> >.

Since a render plugin is to be added using the C<ProcessedPod> interface, it must have the C<custom-raku> and
C<template-raku> keys defined, even if they evaluate to blank (eg. C<:custom-raku()> ).

So the config file must have:
=item render (True | name of callable)
=item custom-raku => a Raku program that evaluates to an array of custom blocks (must be set to C<()> if no Raku program )
=item template-raku => a Raku program that evaluates to a hash of RakuClosure templates (must be set to C<()> if no Raku program)

It is possible to specify C<path> but it must be relative to the plugin's sub-directory.

=head3 Compilation

Note that the structure files are rendered after the C<compilation> stage, BUT the information for rendering
the structure files, that is the custom blocks and the templates must accompany a C< render > plugin.
Compilation plugin callables are to process the data accumulated during the rendering of the content files,
and to make it available for the custom blocks / templates that will be invoked when the structure documents
are rendered.

The C<compilation> key must point to a Raku program that delivers a sub object

    sub ( $pr, %processed, %options ) { ... }

=defn $pr
is the ProcessedPod object rendering the content files.

=defn %processed
is a hash whose keys are source file names with a hash values containing
TOC, Glossary, Links, Metadata, Footnotes, Templates-used structures produced by B<ProcessedPod>.

=defn %options
as for setup

If the return value of the callable is an Array of triplets (as for a Render callable), then
assets are transferred from the plugin directory. Any other type of return value is ignored.

=head3 Transfer

The C<transfer> key points to a Raku file that evaluates to a

    sub ($pr, %processed, %options --> Array ) {...}

=defn %processed
as in Compilation

=defn $pr
as in Compilation

=defn %options
as for Setup

=defn return object
as for the compilation plugin

=head2 Report

The C<report> key points to a Raku file that evaluates to a

    sub (%processed, @plugins-used, $pr, %options --> Array ) {...}

=defn %processed
as in Compilation

=defn @plugins-used
is an array of Pairs whose key is the milestone and
value is a hash of the plugins used and their config parameters.

=defn $pr
as in Compilation

=defn %options
as for Setup

The plugin should return an Array of Pair, where for each Pair
.key = (path/)name of the report file with extension,
and .value is the text of the report in the appropriate format

The C<collect> sub will write the file to the correct directory.

=head3 Completion

The C<completion> key points to a Raku file that evaluates to a

    sub ($destination, $landing-place, $output-ext, %plugin-options, %options) {...}

=begin item
B<$destination>

is the name of the output path from the mode directory (defined in the mode configuration)

=end item
=begin item
B<$landing-place>

is the first file to be processed since, eg., for a website, order is not sufficient. name is relative to the
destination directory.

=end item
=begin item
B<$output-ext>

is the output extension.

=end item
=begin item
B<%plugin-options>

As for Setup
=end item
=begin item
B<%options>

As for Setup
=end item

There is no return value specified for this plugin type.

=head1 Plugin development

There is a separate development distribution C<raku-collection-plugin-development>, which
contains several tools for adding and testing plugins. However, a single plugin can be tested
using the module C<Collection::TestPlugin>, which is included in this distribution.

=head2 Collection plugin specification

All Collection plugins must conform to the following rules
=item The plugin name must:
=item2 start with a letter
=item2 followed by at least one \w or \-
=item2 not contain \_ or \.
=item2 thus a name matches / <alpha> <[\w] + [\-] - [\_]>+ /
=item The plugin directory contains
=item2 C<config.raku>, which is a file that evaluates to a Raku hash.
=item2 README.rakudoc
=item2 t/01-basic.rakutest
=item The C<config.raku> file must contain the following keys
=item2 C<name>. This is the released name of the plugin. It will be possible for a new plugin to have the same
functionality as another, while extending or changing the output. For more detail, see L<Collection plugin management system>.
Typically, the name of the plugin will match the name of the sub-directory it is in.

=item2 C<version>. This point to a Str in the format \d+\.\d+\.\d+ which matches the semantic version
conventions.

=item2 C<auth>. This points to a Str that is consistent with the Raku 'auth' conventions.
=item2 C<license>. Points to a SPDX license type.
=item2 C<authors>. This points to a sequence of names of people who are the authors of the plugin.
=item2 one or more of C<render setup report compilation completion>
=item3 If render then
=item4 the render key may be a boolean
=item4 or the render key is a Str which must
=item5 be a filename in the directory
=item5 be a raku program that evaluated to a callable
=item5 the callable has a signature defined for render callables
=item4 the key C<custom-raku>
=item5 must exist
=item5 must either be empty, viz. C<custom-raku()>
=item5 or must have a Str value
=item5 if it has a Str value and the key C<:information> does contain C<custom-raku> then it is treated
as if C<custom-raku> is empty

=item5 if it has a Str value and the key C<:information> does NOT contain C<custom-raku> then
the Str value should

=item6 point to a file name in the current directory
=item6 and the filename should contain a Raku program that evaluates to an Array.
=item4 the key C<template-raku>
=item5 must exist
=item5 must either be empty, viz. C<template-raku()>
=item5 or must have a Str value
=item5 if it has a Str value and the key C<:information> does contain C<template-raku> then it is treated
as if C<template-raku> is empty

=item5 if it has a Str value and the key C<:information> does NOT contain C<template-raku> then
the Str value should

=item6 point to a file name in the current directory
=item6 and the filename should contain a Raku program that evaluates to a Hash.
=item3 If not render, then the value must point to a Raku program and evaluate to a callable.
=item2 I<Other key names>. If other keys are present, they must point to filenames in the
current directory.

=item2 C<information>. This key does not need to exist.
=item3 If it exists, then it must contain the names of other keys.
=item3 If a key named in the C<:information> list contains a Str,
the filename will NOT exist in the plugin directory, but will
be generated by the plugin itself, or is used as information by the plugin.
=item3 This config key is intended only for plugin testing purposes.

=head2 Collection plugin tests

This distribution contains the module C<Collection::TestPlugin> with a single exported subroutine
C<plugin-ok>. This subroutine verifies that the plugin rules are kept for the plugin.

Additional plugin specific tests should be included.

=head1 Plugin updating

The local computer may contain
=item More than one collection, eg. a personal website and a Raku documentation collection
=item Each Collection may have more than one Mode, eg., a HTML website, an epub producer.
=item A collection/mode combination may rely on a previous API of a plugin, which may be broken
by a later API.

=item A new plugin may have been written as a drop-in replacement for an older version, and the new
plugin may have a different name, or auth, or version.

In order to implement this flexibility, the following are specified:

=item There is a released plugins directory (see L<Released plugins directory>) to contain all
Collection plugins.

=item The semantic versioning scheme is mandated for Collection plugins. A version is
C<v<major>.<minor>,<patch>>. Changes at the C< <patch> > level do not affect the plugin's functionality.
Changes at the C< <minor> > level introduce new functionality, but are backward compatible.
Changes at the C< <major> > level break backward compatibility.

=item Each distributed plugin is contained in the release directory in a subdirectory
named by the plugin name, the
auth field, and the major version number (minor and patch numbers are not included because
they should not by definition affect the API).

=item Each Mode configuration only contains the name of the plugin (without the auth, or version names).
=item The developer may define which name/version/auth of a released plugin is to be mapped
to the plugin required in the Mode configuration. Thus

=item2 changes in API can be frozen to earlier versions of the plugin for some concrete Mode.
=item2 different plugin versions can be used for different collection/modes
=item2 a differently named plugin can be mapped to a plugin required by a specific collection/mode.
=item3 B<Note> an alternate plugin, as given by C<name> may also have a non-default C<auth>, so
C<auth> may need to be added to C<plugins.rakuon> as well.

=item Consequently, all released plugins are defined for
=item2 a B<format> (eg. html)
=item2 a B<major> version
=item2 an B<auth> name
=item The mapping information from a released plugin to a Mode is contained in a file in the root
of a Collection.

=item When the plugins are updated
=item2 all the latest versions for each Format/Name/Version/Auth are downloaded.
=item2 a symlink is generated (or if the OS does not allow symlink, the whole directory is copied)
from the released version to the directory where
each mode expects its plugins to be located.

=item Each Collection root directory (the directory containing the topmost C<config.raku> file)
will contain the file C<plugins.rakuon>.

=item The plugin management tool (PMT)
=item2 checks if a C<plugins.rakuon> exists. If not, it generates a minimal one.
=item2 runs through the plugins-required of each B<Mode> in the collection.
=item2 for each distinct plugin verifies whether
=item3 the plugin has an entry in C<plugins.rakuon>, in which case
=item4 the PMT maps (or remaps if the constraint is new)
the released plugin name/auth/ver to the plugin-required name using the rules
of C<plugins.rakuon> as given in L<Mapping released plugins to mode directories>

=item3 the plugin does not have an entry, which means it has not yet been mapped,
and there are no constraints on the plugin, so
the default name/auth/version are used.

=head2 Mapping released plugins to mode directories

The file C<plugins.rakuon> contains a hash with the following keys:
=item C<_metadata_>. Contains a hash with data for the C<refresh> functionality.
=item2 C<collection-plugin-root> This contains the name of a directory reachable from the Collection
root directory with the released plugins are downloaded.
=item2 C<update-behaviour> Defines what happens when a new released plugin has an increased
Major number. Possible values are:

=item3 I<auto> All relevant plugin names are updated to the new version, a message is issued
=item3 I<conserve> Plugins are not updated to the new version, a warning is issued,
updating is then plugin by plugin with a C<-force> flag set.

=item3 B<Note> The update behaviour is not initially implemented.

=item Every other toplevel key that meets the plugin naming convenstion
is interpreted as a Mode. This means a mode cannot be named C<_metadata_>.

=item The Mode key will point to a hash with the keys:
=item2 C<_mode_format> Each mode may only contain plugins from one Format, eg., I<html>.
=item2 By the plugin naming rules, a I<plugin> may not be named C<_mode_format>.
=item2 Every other key in a mode hash must be a plugin name contained
in the Mode's plugins-required configuration.

=item2 There may be zero plugin keys

=item2 If a plugin in the plugins-required configuration list does not have an entry
at this level, then it has not been mapped to a sub-directory of the C<released-directory>.

=item2 A plugin key that exists must point to a Hash, which must at least contain:
=item3 mapped => the name of the released plugin
=item2 The plugin hash may also point to one or more of:
=item3 name => the name of the alternate released plugin
=item4 the default name (if the key is absent) is the plugin-required's name
=item4 if a different name is given, a released plugin is mapped to the required directory in the
mode sub-directory

=item3 major => the major number preceeded by 'v'
=item4 the default value (if the key is absent) is the greatest released major value
=item4 A major value is the maximum major value of the full version permitted, thus freezing at that version
=item3 auth => the auth value
=item4 the default value (if the key is absent) is 'collection'
=item2 If there is no distributed plugin for a specified C<auth | major | name >, then an error is thrown.

Some examples:
=begin item
The Raku-Collection-Raku-Documentation, Website mode, requires the plugin C<Camelia>. The plugin exists
as a HTML format. It has version 1.0.0, and an auth 'collection'. It is distributed as
C<html/camelia_v1_auth_collection>. Suppose a version with a new API is created. Then
two versions of the plugin will be distributed, including the new one
C<html/camelia_v2_auth_collection>.

If the key for camelia in the hash for mode Website only contains an empty C<version> key,
then the defaults will be implied and
a link (or copy) will be made between the released directory
C<html/camelia_v2_auth_collection> and C<Website/plugins/camelia>
=end item
=begin item
If plugins.rakuon contains the following:
C<Website => %( :FORMAT<html>, :camelia( %( :major(1), ) ) >
then the link will be between C<html/camelia_v1_auth_collection> and C<Website/plugins/camelia>
=end item
=begin item
Suppose there is another valid C<auth> string B<raku-dev> and there is a distributed plugin
I<html/camelia_v2_auth_raku-dev>, and suppose C<plugins.rakuon> contains the following:
C<Website => %( :FORMAT<html>, :camelia( %( :auth<raku-dev>, ) ) > then the link will be made
between C<html/camelia_v2_auth_raku-dev> and C<Website/plugins/camelia>
=end item
=begin item
Suppose a different icon is developed called C<new-camelia> by C<auth> B<raku-dev>, then
C<plugins.rakuon> may contain the following:
C<Website => %( :FORMAT<html>, camelia( %( :name<new-camelia>, :auth<raku-dev>, ) ) > then
a link (copy) is made between C<html/new-camelia_v2_auth_raku-dev> and C<Website/plugins/camelia>
=end item
=item2 Note how the auth must be given for a renaming if there is not a C<collection> version
of the plugin

=head2 Released plugins directory

When Collection is installed, a directory called (by default) C<$*HOME/.local/share/Collection> is created
(on a Linux system this will be the same as C< ~/.local/share/Collection>).

If the Environment variable C<PluginPath> is set to a valid path name upon installation,
then that will be used instead. But when C<refresh-collection-plugins> is first
used, then the non-default name must be supplied.

The directory is initialised to point at the C<https://github.com/finanalyst/collection-plugins>
repo and the C<manifest.rakuon> file is downloaded.

If another release directory location is desired, then
=item it can be specified when
C<refresh-collection-plugins> is first run for each collection, in which case
the file C<plugin.rakuon> is given the value for the C<:collection-plugin-root>.

=item a custom Raku program for refreshing Collection files can be written,
eg., the github repo is to be located in C<~/.my_own_collection>
=begin code
use v6.d;
use Collection::RefreshPlugins;
sub MAIN(|c) {
    $Collection::RefreshPlugins::release-dir = "$*HOME/.my_own_collection";
    refresh( |c );
}
=end code

=head2 Refresh process

The intent is for the released plugins to be held in a single directory (called the
I<released plugins> directory), and for the references in a Collection-Mode
C<plugins> directory to be links (OS dependent) to the I<released plugins> directory.

The I<released plugins> directory is a Github repository, so doing a C<git pull>
will pull in the most recent versions of the plugins. Consequently, each Collection-Mode
plugin reference will automatically be updated.

A C<git pull> is therefore one form of a refresh. (TODO if an OS does not have
directory links, then this form of refresh will need to be enhanced with a
copy operation).

Refresh needs to deal with other situations
=item A new plugin name is added to the Collection-Mode's C<plugins-required> list.
=item2 A link needs to be added to the Collections-Mode's C<plugins> directory.
=item A new entry exists for the plugin name in the C<plugins.rakuon>
=item2 An entry changes the release name associated with the Collection-Mode plugin.
=item3 If the desired released plugin does not exist, then an Exception is thrown. Default
behaviour might lead to an infinite loop.

=item A released plugin major version has increased since the last refresh.
=item2 The default is for a Collection-Mode plugin initially to be linked to the most
recent version of the plugin

=item2 Several behaviours are possible:
=item3 The default I<update-behaviour> is given in the C<_metadata_> hash of C<plugins.rakuon>
=item3 I<force> Leave the existing links in place, issue a warning,
update to latest only when forced. Include suggestion to change plugins.rakuon file
to suppress warnings.

=item3 I<auto> (default) Automatically update to the latest version, issuing a message

=head2 CLI Plugin Management System

Collection contains the utility C<collection-refresh-plugins> as
a (PMS). It is called as follows:

    collection-refresh-plugins [-collection=<path>] [-collections='path1 path2 path3']

C<-collection> is the path to a Collection directory. By default it is the Current Working Directory.

C<-collections> is a space delimited list of paths to Collections

When a Collection directory contains a file C<plugins.rakuon>, then the utility will inspect the release directory,
updates it, and maps (copy) the most recent plugins according this file. See below for more detail about
the specification of C<plugins.rakuon>.

When a Collection does not contain a file <plugins.rakuon>, it generates one from the C<plugin-required>
key of each of the C<config.raku> files in each Mode. During this process, the user is prompted
for the directory name (relative to the current working directory) of released plugin directory.

=head1 Problems and TODO items

=head2 Archiving and Minor Changes

In principle, if a small change is made in a source file of a Collection, only the rendered version
of that file should be changed, and the Collection pages (eg., the index and the glossaries) updated.
The archiving method chosen here is based on C<Archive::Libarchive> and a C<.7z> format. It works in
tests where a small quantity of data is stored.

B<However>, when there are many source files (eg., the Raku documentation),
the process of restoring state information is B<significantly> longer
than re-rendering all the cached files. Consequently, the option C<no-preserve-state> prevents
the archiving of processed state. (TODO understanding and optimising the de-archiving process.)

=head2 Dump file formatting

The aim is to use C<PrettyDump> instead of <.raku> to transform information into text. However, <PrettyDump> does
not handle C<Bags> properly.

=head1 Post-cache methods

Post-cache is a role added to a C<Pod::From::Load> object so that Setup plugin callables can act on Cache'd content
by adding pod files to the Cache (perhaps pre-processing primary source files) that will be rendered,
masking primary pod files so that they are not rendered, or aliasing primary pod files.

If a secondary source file in the Cache is given a name that is the same as a primary source file,
then if the underlying cache object should remain visible, another name (alias) should be given to the
file in the Post-cache database.

The Post-cache methods C<sources>, C<list-files>, and C<pod> have the same function and semantics as
C<Pod::From::Cache> except that the post-cache database is searched first, and if contents are found there,
the contents are returned (which is why post-cache file names hide primary file names).
If there is no name in the Post-cache
database, then it is passed on to the underlying cache.

=head2 multi method add(Str $fn, Array $p --> Pod::From::Cache )

Adds the filename $fn to the cache. $p is expected to be an array of Pod::Blocks, but no check is made. This is
intentional to allow the developer flexibility, but then a call to C<pod( $fn )> will yield an array that is not
POD6, which might not be expected.

The invocant is returned, thus allowing add to be chained with mask and alias.

=head2 multi method mask(Str $fn --> Pod::From::Cache)

This will add only a filename to the database, and thus mask any existing filename in the underlying cache.

Can be chained.

=head2 multi method add-alias(Str $fn, Str :alias!  --> Pod::From::Cache)

This will add a filename to the database, with the value of a key in the underlying cache.
Chain with mask to prevent the original spelling of the filename in the underlying cache being visible.

Can be chained.

If the alias is already taken, an exception is thrown. This will even occur if the same alias
is used for the same cached content file.

=head2 method behind-alias(Str $fn --> Str )

Returns the original name of the cached content file, if an alias has been created, otherwise
returns the same filename.

=head2 method pod(Str $fn)

Will return
=item an array of Pod::Block (or other content - beware of adding other content) if the
underlying Cache or database have content,

=item the array of Pod::Block in an underlying filename, spelt differently

=item C<Nil> if there is no content (masking an underlying file in Cache)

=item throw a NoPodInCache Exception if there is no pod associated with either the database
or the underlying cache. If the original filename is used after an alias have been generated,
the Exception will also be thrown.

=head1 Asset-cache methods

Asset-cache handles content that is not in Pod6 form. The instance of the Asset-cache class is passed via the
plugin-data interface of C<ProcessedPod>, so it is available to all plugin callables after the setup milestone,
for example in the plugin callable:

    sub render-plugin( $pp ) {
        my $image-manager = $pp.get-data('image-manager');
        ...
        $pp.add-data('custom-block', $image-manager);
    }

By creating a name-space in the plugin data section and assigning it the value of the image-manager,
the plugin callable can make the image-manager available to templates that get that data, which is a property
in parameters called by the name-space.

C<ProcessedPod> provides data from the name-space of a Block, if it exists, as a parameter to the
template called for the Block. Note that the default name-space for a block is
all lower-case, unless a C<name-space> config option is provided with the
Pod Block in the content file.

If a plugin provides an asset (eg., image, jquery script), it needs to provide a C<render> callable
that returns the triple so that Collect moves the asset from the plugin directory to the output
directory where it can be served. This needs to be done separately if a CSS contains a url for
local image.

The basename for the assets is set in the Top level configuration in the option C<asset-basename>

C<$image-manager> is of type Asset-cache, which has the following methods:

=begin code
    #| the directory base, not included in filenames
    has Str $.basename is rw;
    #| the name of the file being rendered
    Str $.current-file
    #| asset-sources provides a list of all the items in the cache
    method asset-sources
    #| asset-used-list provides a list of all the items that referenced by Content files
    method asset-used-list
    #| asset-add adds an item to the data-base, for example, a transformed image
    method asset-add( $name, $object, :$by = (), :$type = 'image' )
    #| returns name / type / by information in database (not the object blob)
    method asset-db
    #| remove the named asset, and return its metadata
    method asset-delete( $name --> Hash )
    #| returns the type of the asset
    method asset-type( $name --> Str )
    #| if an asset with name and type exists in the database, then it is marked as used by the current file
    #| returns true with success, and false if not.
    method asset-is-used( $asset, $type --> Bool )
    #| brings all assets in directory with given extensions and with type
    #| these are set in the configuration
    multi method asset-slurp( $directory,  @extensions, $type )
    #| this just takes the value of the config key in the top-level configuration
    multi method asset-slurp( %asset-paths )
    #| with type 'all', all the assets are sent to the same output directory
    multi method asset-spurt( $directory, $type = 'all' )
    #| the value of the config key in the mode configuration
    multi method asset-spurt( %asset-paths )
=end code

=head1 Copyright and License

(c) Copyright, 2021-2022 Richard Hainsworth

B<LICENSE> Artistic-2.0

=end pod